"use strict";(self.webpackChunk=self.webpackChunk||[]).push([[3955],{3905:(e,t,n)=>{n.d(t,{Zo:()=>m,kt:()=>h});var a=n(67294);function l(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function r(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);t&&(a=a.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,a)}return n}function i(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?r(Object(n),!0).forEach((function(t){l(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):r(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function o(e,t){if(null==e)return{};var n,a,l=function(e,t){if(null==e)return{};var n,a,l={},r=Object.keys(e);for(a=0;a<r.length;a++)n=r[a],t.indexOf(n)>=0||(l[n]=e[n]);return l}(e,t);if(Object.getOwnPropertySymbols){var r=Object.getOwnPropertySymbols(e);for(a=0;a<r.length;a++)n=r[a],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(l[n]=e[n])}return l}var s=a.createContext({}),p=function(e){var t=a.useContext(s),n=t;return e&&(n="function"==typeof e?e(t):i(i({},t),e)),n},m=function(e){var t=p(e.components);return a.createElement(s.Provider,{value:t},e.children)},u="mdxType",c={inlineCode:"code",wrapper:function(e){var t=e.children;return a.createElement(a.Fragment,{},t)}},d=a.forwardRef((function(e,t){var n=e.components,l=e.mdxType,r=e.originalType,s=e.parentName,m=o(e,["components","mdxType","originalType","parentName"]),u=p(n),d=l,h=u["".concat(s,".").concat(d)]||u[d]||c[d]||r;return n?a.createElement(h,i(i({ref:t},m),{},{components:n})):a.createElement(h,i({ref:t},m))}));function h(e,t){var n=arguments,l=t&&t.mdxType;if("string"==typeof e||l){var r=n.length,i=new Array(r);i[0]=d;var o={};for(var s in t)hasOwnProperty.call(t,s)&&(o[s]=t[s]);o.originalType=e,o[u]="string"==typeof e?e:l,i[1]=o;for(var p=2;p<r;p++)i[p]=n[p];return a.createElement.apply(null,i)}return a.createElement.apply(null,n)}d.displayName="MDXCreateElement"},21014:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>m,contentTitle:()=>s,default:()=>d,frontMatter:()=>o,metadata:()=>p,toc:()=>u});var a=n(87462),l=(n(67294),n(3905)),r=n(74866),i=n(85162);const o={title:"Section 04 (Jared Yeager)"},s="Map, Filter, and Lambda Functions",p={unversionedId:"Lambdas/Jared/index",id:"Lambdas/Jared/index",title:"Section 04 (Jared Yeager)",description:"In a previous lecture we learned about mapping and filtering.",source:"@site/main/lectures/22_Lambdas/Jared/index.md",sourceDirName:"22_Lambdas/Jared",slug:"/Lambdas/Jared/",permalink:"/main/lectures/Lambdas/Jared/",draft:!1,tags:[],version:"current",frontMatter:{title:"Section 04 (Jared Yeager)"},sidebar:"tutorialSidebar",previous:{title:"Lec 22 Lambdas",permalink:"/main/lectures/Lambdas/"}},m={},u=[{value:"Map and Filter",id:"map-and-filter",level:2},{value:"Going Meta (Higher-Order Functions)",id:"going-meta-higher-order-functions",level:3},{value:"Map",id:"map",level:3},{value:"Filter",id:"filter",level:3},{value:"Lambdas",id:"lambdas",level:2},{value:"When to Use What",id:"when-to-use-what",level:2},{value:"<code>map()</code> and <code>filter()</code>",id:"map-and-filter-1",level:3},{value:"Comprehensions",id:"comprehensions",level:3},{value:"Lambdas",id:"lambdas-1",level:3},{value:"Reduce",id:"reduce",level:2},{value:"Iterative Form",id:"iterative-form",level:3},{value:"Python Function",id:"python-function",level:3}],c={toc:u};function d(e){let{components:t,...n}=e;return(0,l.kt)("wrapper",(0,a.Z)({},c,n,{components:t,mdxType:"MDXLayout"}),(0,l.kt)("h1",{id:"map-filter-and-lambda-functions"},"Map, Filter, and Lambda Functions"),(0,l.kt)("p",null,"In a ",(0,l.kt)("a",{parentName:"p",href:"../looping-patterns/Jared"},"previous lecture")," we learned about mapping and filtering."),(0,l.kt)("ul",null,(0,l.kt)("li",{parentName:"ul"},"Mapping is transforming every element in a collection."),(0,l.kt)("li",{parentName:"ul"},"Filtering is getting every element in a collection that satisfies some condition.")),(0,l.kt)("p",null,"We learned about these in the context of comprehensions,\nand how comprehensions let us do these things fairly succinctly."),(0,l.kt)("p",null,'Now we introduce special functions for an alternative way to do these things,\nand in the process, introduce the concept of "higher-order functions".'),(0,l.kt)("h2",{id:"map-and-filter"},"Map and Filter"),(0,l.kt)("h3",{id:"going-meta-higher-order-functions"},"Going Meta (Higher-Order Functions)"),(0,l.kt)("admonition",{type:"info"},(0,l.kt)("p",{parentName:"admonition"},"This sub-section is actually outside the scope of what you really need to know,\nbut it is what underlies our ability to have the ",(0,l.kt)("inlineCode",{parentName:"p"},"map()")," and ",(0,l.kt)("inlineCode",{parentName:"p"},"filter()")," functions\nat all."),(0,l.kt)("p",{parentName:"admonition"},"I don't feel comfortable not addressing the elephant in the room\nthat we will be standing on for the rest of the lecture.")),(0,l.kt)("p",null,"Consider a couple of different mapping examples:"),(0,l.kt)("ul",null,(0,l.kt)("li",{parentName:"ul"},"Converting a list of strings to ints"),(0,l.kt)("li",{parentName:"ul"},"Converting a list of ints to strings"),(0,l.kt)("li",{parentName:"ul"},"Square rooting a list of numbers"),(0,l.kt)("li",{parentName:"ul"},"Squaring a list of numbers")),(0,l.kt)(r.Z,{mdxType:"Tabs"},(0,l.kt)(i.Z,{value:"str_to_int",label:"String to Int",default:!0,mdxType:"TabItem"},(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-py",metastring:"live_py title=String_to_Int",live_py:!0,title:"String_to_Int"},'l = ["3","1","4","1","5","9","2"]\nnew_l = []\nfor x in l:\n  new_l.append(int(x))\nprint(new_l)\n'))),(0,l.kt)(i.Z,{value:"int_to_str",label:"Int to String",mdxType:"TabItem"},(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-py",metastring:"live_py title=Int_to_String",live_py:!0,title:"Int_to_String"},"l = [3,1,4,1,5,9,2,6]\nnew_l = []\nfor x in l:\n  new_l.append(str(x))\nprint(new_l)\n"))),(0,l.kt)(i.Z,{value:"sqrt",label:"Square Root",mdxType:"TabItem"},(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-py",metastring:"live_py title=_Square_Root",live_py:!0,title:"_Square_Root"},"from math import sqrt\n\nl = [3,1,4,1,5,9,2,6]\nnew_l = []\nfor x in l:\n  new_l.append(sqrt(x))\nprint(new_l)\n"))),(0,l.kt)(i.Z,{value:"square",label:"Square",mdxType:"TabItem"},(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-py",metastring:"live_py title=Square",live_py:!0,title:"Square"},"l = [3,1,4,1,5,9,2,6]\nnew_l = []\nfor x in l:\n  new_l.append(x ** 2)\nprint(new_l)\n")))),(0,l.kt)("p",null,"In all of these, the core mapping as always of the form:"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-py"},"new_list = []\nfor element in COLLECTION:\n  new_list.append(MAP_FUNCTION(element))\n")),(0,l.kt)("p",null,"And in that view, these mappings are all the same except for our choices of"),(0,l.kt)("ul",null,(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("inlineCode",{parentName:"li"},"COLLECTION"),", the collection we want to transform, and"),(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("inlineCode",{parentName:"li"},"MAP_FUNCTION"),", the transformation in question.")),(0,l.kt)("p",null,'If you ever find yourself thinking "all of these things are the same except for ..."\nThe you probably want to extract the similarities into a function\nand have those differences be the parameters.'),(0,l.kt)("p",null,"You might think there is a catch here, in that one of our two parameters-to-be,\n",(0,l.kt)("inlineCode",{parentName:"p"},"MAP_FUNCTION"),", is a ",(0,l.kt)("strong",{parentName:"p"},"function"),".\nBut, in Python, we can totally just pass functions to functions.\nWe call functions that take in (or return) functions ",(0,l.kt)("em",{parentName:"p"},"higher-order functions"),',\nand we say "Python supports higher-order functions".'),(0,l.kt)("p",null,"And so we can make this general mapping function:"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-py",metastring:"live_py title=Meta_Map",live_py:!0,title:"Meta_Map"},'from math import sqrt\n\ndef my_map(fun, itr): # map() is taken, as we will soon see\n  new_list = []\n  for element in itr:\n    new_list.append(fun(element))\n  return new_list\n\ndef square(x):\n  return x ** 2\n\nints = my_map(int, ["3","1","4","1","5","9","2"])\nstrs = my_map(str, [3,1,4,1,5,9,2,6])\nsqrts = my_map(sqrt, [3,1,4,1,5,9,2,6])\nsquares = my_map(square, [3,1,4,1,5,9,2,6])\nprint(ints)\nprint(strs)\nprint(sqrts)\nprint(squares)\n')),(0,l.kt)("p",null,"Notice how I needed to make a function for ",(0,l.kt)("inlineCode",{parentName:"p"},"square")," in order to be able to pass it in,\nwe'll come back to this later."),(0,l.kt)("h3",{id:"map"},"Map"),(0,l.kt)("p",null,"We've just re-invented the wheel.\nPython already has a function, ",(0,l.kt)("inlineCode",{parentName:"p"},"map()"),", that takes in a function for the transformation and\na collection to map the function over. ",(0,l.kt)("inlineCode",{parentName:"p"},"map()")," returns a special ",(0,l.kt)("inlineCode",{parentName:"p"},"map")," object,\nwhich can be converted to a list or other collection type in the usual manner."),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-py",metastring:"live_py title=Map",live_py:!0,title:"Map"},'to_nums = map(int, ["3","1","4","1","5","9","2"])\nprint(to_nums)\nprint(list(to_nums))\n')),(0,l.kt)("p",null,"This is generalised higher-order mapping function,\nso great for applying functions to a whole collection."),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-py",metastring:"live_py title=Map_",live_py:!0,title:"Map_"},'from math import sqrt\n\ndef square(x):\n  return x ** 2\n\nints = map(int, ["3","1","4","1","5","9","2"])\nstrs = map(str, [3,1,4,1,5,9,2,6])\nsqrts = map(sqrt, [3,1,4,1,5,9,2,6])\nsquares = map(square, [3,1,4,1,5,9,2,6])\nprint(list(ints))\nprint(list(strs))\nprint(list(sqrts))\nprint(list(squares))\n')),(0,l.kt)("h3",{id:"filter"},"Filter"),(0,l.kt)("p",null,"Analogously to before, the core portion of a filtering operation looks like:"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-py"},"new_list = []\nfor element in COLLECTION:\n  if CONDITION(element):\n    new_list.append(element)\n")),(0,l.kt)("p",null,"We can see the only variables are:"),(0,l.kt)("ul",null,(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("inlineCode",{parentName:"li"},"COLLECTION"),", the collection we want to filter, and"),(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("inlineCode",{parentName:"li"},"CONDITION"),", a function that checks if we want to keep an element or not.")),(0,l.kt)("p",null,'So we could imagine a sort of "general filter" function.'),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-py",metastring:"live_py title=Meta_Filter",live_py:!0,title:"Meta_Filter"},"def my_filter(cond, itr): # filter() is taken, as you may imagine\n  new_list = []\n  for element in itr:\n    if cond(element):\n      new_list.append(element)\n  return new_list\n\ndef is_even(x):\n  return x % 2 == 0\n\ndef is_odd(x):\n  return x % 2 == 1\n\nl = [3,1,4,1,5,9,2,6]\nevens = my_filter(is_even, l)\nodds = my_filter(is_odd, l)\nprint(evens)\nprint(odds)\n")),(0,l.kt)("p",null,"But like before,\nPython has a function, ",(0,l.kt)("inlineCode",{parentName:"p"},"filter()"),", that takes in a function for the condition we want and\na collection to filter based on that condition being true.\n",(0,l.kt)("inlineCode",{parentName:"p"},"filter()")," returns a special ",(0,l.kt)("inlineCode",{parentName:"p"},"filter")," object,\nwhich can be converted to a list or other collection type in the usual manner."),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-py",metastring:"live_py title=Filter",live_py:!0,title:"Filter"},"def is_even(x):\n  return x % 2 == 0\n\ndef is_odd(x):\n  return x % 2 == 1\n\nl = [3,1,4,1,5,9,2,6]\nevens = filter(is_even, l)\nodds = filter(is_odd, l)\nprint(list(evens))\nprint(list(odds))\n")),(0,l.kt)("h2",{id:"lambdas"},"Lambdas"),(0,l.kt)("p",null,"Remember how in order to map squaring across a list I needed to make a ",(0,l.kt)("inlineCode",{parentName:"p"},"square()")," function\nto give to the ",(0,l.kt)("inlineCode",{parentName:"p"},"map()")," function?"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-py",metastring:"live_py title=Square_Fun",live_py:!0,title:"Square_Fun"},"def square(x):\n  return x ** 2\n\nsquares = map(square, [3,1,4,1,5,9,2,6])\nprint(list(squares))\n")),(0,l.kt)("p",null,"That's kind of annoying, or at least ",(0,l.kt)("strong",{parentName:"p"},"I")," don't like that."),(0,l.kt)("p",null,"Well, conveniently enough for us,\npython has machinery for creating nameless, purely expression-based functions\non the fly."),(0,l.kt)("p",null,"These functions are known as lambda functions.\n(The name comes from ",(0,l.kt)("a",{parentName:"p",href:"https://en.wikipedia.org/wiki/Lambda_calculus"},"lambda calculus"),",\na very elegant, function-based model of computation.)\nThe python syntax for making such a function is:"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-py"},"lambda COMMA_SEPARATED_VARIABLES: EXPRESSION_FOR_RETURN\n")),(0,l.kt)("p",null,"The pieces are:"),(0,l.kt)("ul",null,(0,l.kt)("li",{parentName:"ul"},"The keyword ",(0,l.kt)("inlineCode",{parentName:"li"},"lambda")),(0,l.kt)("li",{parentName:"ul"},"0 or more variable names for parameters separated by commas"),(0,l.kt)("li",{parentName:"ul"},"A colon (",(0,l.kt)("inlineCode",{parentName:"li"},":"),")"),(0,l.kt)("li",{parentName:"ul"},"An expression, that may use the parameters, for computing a return.")),(0,l.kt)("p",null,"Some things to note:"),(0,l.kt)("ul",null,(0,l.kt)("li",{parentName:"ul"},"There is no return keyword, yet the thing to the right of the colon is always returned"),(0,l.kt)("li",{parentName:"ul"},"The function can only have an expression, no control flow stuff")),(0,l.kt)("p",null,"As an example, ",(0,l.kt)("inlineCode",{parentName:"p"},"lambda x, y: 2*x + y")," would be a nameless function that takes in\ntwo variables, and returns twice the first plus the second."),(0,l.kt)("p",null,"And so we can do the map square from before as:"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-py",metastring:"live_py title=Square_Fun_Lambda",live_py:!0,title:"Square_Fun_Lambda"},"squares = map(lambda x: x**2, [3,1,4,1,5,9,2,6])\nprint(list(squares))\n")),(0,l.kt)("p",null,"Here are some more examples with filtering,\nwhere the lambda function is used to invoke the methods:"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-py",metastring:"live_py title=Filter_Lambda",live_py:!0,title:"Filter_Lambda"},'l = ["Hello", "bye", "3.14159", "2178", "foo", "42"]\nnumbers = filter(lambda s: s.isdigit(), l)\nwords = filter(lambda s: s.isalpha(), l)\nlowers = filter(lambda s: s.islower(), l)\nprint(list(numbers))\nprint(list(words))\nprint(list(lowers))\n')),(0,l.kt)("hr",null),(0,l.kt)("admonition",{type:"caution"},(0,l.kt)("p",{parentName:"admonition"},"Material from here on was not part of the lecture,\nbut is stuff that I think is necessary to complete the story.")),(0,l.kt)("hr",null),(0,l.kt)("h2",{id:"when-to-use-what"},"When to Use What"),(0,l.kt)("p",null,"We've seen that we can accomplish mapping and filtering both with comprehensions\nand with the ",(0,l.kt)("inlineCode",{parentName:"p"},"map()")," and ",(0,l.kt)("inlineCode",{parentName:"p"},"filter()")," functions\n(including with lambda functions if need be)."),(0,l.kt)("p",null,'There is no "right way" to do things, but I want to offer my thinking about\nwhere it makes sense to me to use each of these.'),(0,l.kt)("h3",{id:"map-and-filter-1"},(0,l.kt)("inlineCode",{parentName:"h3"},"map()")," and ",(0,l.kt)("inlineCode",{parentName:"h3"},"filter()")),(0,l.kt)("p",null,"If we have a specific named function that we wish to map or filter with,\nthen I lean toward ",(0,l.kt)("inlineCode",{parentName:"p"},"map()")," and ",(0,l.kt)("inlineCode",{parentName:"p"},"filter()")," over comprehensions,\nfor example, mapping ",(0,l.kt)("inlineCode",{parentName:"p"},"int()")," to convert a bunch of strings to ints, as below."),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-py",metastring:"live_py title=Direct_Map_VS",live_py:!0,title:"Direct_Map_VS"},'l = ["3","1","4","1","5","9","2"]\nprint([int(x) for x in l])\nprint(list(map(int, l)))\n')),(0,l.kt)("p",null,"If we want to map something ",(0,l.kt)("strong",{parentName:"p"},"and then")," filter the results\n(other way around is a different story),\na comprehension isn't really a natural way to do that (you need a weird nested thing),\nso ",(0,l.kt)("inlineCode",{parentName:"p"},"map()")," and ",(0,l.kt)("inlineCode",{parentName:"p"},"filter()")," are more natural to me."),(0,l.kt)("p",null,"Consider an example where we convert a bunch of strings to ints or ",(0,l.kt)("inlineCode",{parentName:"p"},"None"),"s (on error),\nand then filter out the things we couldn't convert to ints."),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-py",metastring:"live_py title=Map_Then_Filter_VS",live_py:!0,title:"Map_Then_Filter_VS"},'def safe_int(s):\n  try:\n    return int(s)\n  except:\n    return None\n\nl = ["314", "Hello", "foo", "42", "17.5", "2718", "bar"]\nprint([x for x in [safe_int(s) for s in l] if x is not None])\nprint(list(filter(lambda x: x is not None, map(safe_int, l))))\n')),(0,l.kt)("details",null,(0,l.kt)("summary",null,(0,l.kt)("b",null,"Extra: Well, Actually ...")),(0,l.kt)("p",null,"That's assuming what we've taught you.\nHowever, I would actually abuse the walrus operator\n(",(0,l.kt)("inlineCode",{parentName:"p"},":="),", mid-expression assignment) and the order in which things are evaluated to\nget a more viable comprehension."),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-py",metastring:"live_py title=Map_Then_Filter_Walrus",live_py:!0,title:"Map_Then_Filter_Walrus"},'def safe_int(s):\n  try:\n    return int(s)\n  except:\n    return None\n\nl = ["314", "Hello", "foo", "42", "17.5", "2718", "bar"]\nprint([x for s in l if (x := safe_int(s)) is not None])\nprint([x for x in [safe_int(s) for s in l] if x is not None])\nprint(list(filter(lambda x: x is not None, map(safe_int, l))))\n'))),(0,l.kt)("h3",{id:"comprehensions"},"Comprehensions"),(0,l.kt)("p",null,"Where mapping and filtering are more abstractly concerned, comprehensions are my default."),(0,l.kt)("p",null,"If I need to make a lambda function in order to use ",(0,l.kt)("inlineCode",{parentName:"p"},"map()")," or ",(0,l.kt)("inlineCode",{parentName:"p"},"filter()"),",\nI'll probably just do a comprehension. Such as the squaring from before."),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-py",metastring:"live_py title=Square_VS",live_py:!0,title:"Square_VS"},"l = [3,1,4,1,5,9,2,6]\nprint([x**2 for x in l])\nprint(list(map(lambda x: x**2, l)))\n")),(0,l.kt)("p",null,"If we want some sort of nesting, either of the loops generating/mapping the collection(s)\nor of the resultant collection, I find comprehensions more natural to use."),(0,l.kt)("p",null,"Two examples below:"),(0,l.kt)("ul",null,(0,l.kt)("li",{parentName:"ul"},"Making a 1D collection of 2D points based on nested looping\n(only really doable with comprehensions, I think)"),(0,l.kt)("li",{parentName:"ul"},"Making a 2D collection of 2D points based on nested mapping")),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-py",metastring:"live_py title=Nested_Mapping_VS",live_py:!0,title:"Nested_Mapping_VS"},"# 1D list can only really be done this way with comprehensions\nprint([(i,j) for i in range(3) for j in range(3)])\n# 2D grid is grosser to do with lambdas\nprint([[(i,j) for j in range(3)] for i in range(3)])\nprint(list(map(lambda i: list(map(lambda j: (i,j), range(3))), range(3))))\n")),(0,l.kt)("p",null,"Comprehensions are also much more natural in the case where you want to filter\n",(0,l.kt)("strong",{parentName:"p"},"and then")," map. For instance: getting all even numbers and then dividing those by two."),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-py",metastring:"live_py title=Filter_Then_Map_VS",live_py:!0,title:"Filter_Then_Map_VS"},"l = [3,1,4,1,5,9,2,6]\nprint([x//2 for x in l if x % 2 == 0])\nprint(list(map(lambda x: x//2, filter(lambda x: x % 2 == 0, l))))\n")),(0,l.kt)("h3",{id:"lambdas-1"},"Lambdas"),(0,l.kt)("p",null,"You may have noticed that my take is effectively:\nif we want to use ",(0,l.kt)("inlineCode",{parentName:"p"},"map()")," or ",(0,l.kt)("inlineCode",{parentName:"p"},"filter()")," and need a lambda function,\nwe might as well use a comprehension."),(0,l.kt)("p",null,"So then where do lambdas fit in? Well, uh, the entire next optional section, but ...\nbasically any other time you want to give a function a pure-expression function\nthat isn't worth making a more permanent function.\nBasically any time you want to avoid defining a more permanent function."),(0,l.kt)("p",null,"It just so happens that in Python mapping and filtering are already\nreally well covered by comprehensions."),(0,l.kt)("p",null,"But as an example, if I had a function that computed an approximate definite integral\n(approximate bounded area under a curve),\nI would pass in functions for things like ",(0,l.kt)("span",{parentName:"p",className:"math math-inline"},(0,l.kt)("span",{parentName:"span",className:"katex"},(0,l.kt)("span",{parentName:"span",className:"katex-mathml"},(0,l.kt)("math",{parentName:"span",xmlns:"http://www.w3.org/1998/Math/MathML"},(0,l.kt)("semantics",{parentName:"math"},(0,l.kt)("mrow",{parentName:"semantics"},(0,l.kt)("msup",{parentName:"mrow"},(0,l.kt)("mi",{parentName:"msup"},"x"),(0,l.kt)("mn",{parentName:"msup"},"2"))),(0,l.kt)("annotation",{parentName:"semantics",encoding:"application/x-tex"},"x^2")))),(0,l.kt)("span",{parentName:"span",className:"katex-html","aria-hidden":"true"},(0,l.kt)("span",{parentName:"span",className:"base"},(0,l.kt)("span",{parentName:"span",className:"strut",style:{height:"0.8141em"}}),(0,l.kt)("span",{parentName:"span",className:"mord"},(0,l.kt)("span",{parentName:"span",className:"mord mathnormal"},"x"),(0,l.kt)("span",{parentName:"span",className:"msupsub"},(0,l.kt)("span",{parentName:"span",className:"vlist-t"},(0,l.kt)("span",{parentName:"span",className:"vlist-r"},(0,l.kt)("span",{parentName:"span",className:"vlist",style:{height:"0.8141em"}},(0,l.kt)("span",{parentName:"span",style:{top:"-3.063em",marginRight:"0.05em"}},(0,l.kt)("span",{parentName:"span",className:"pstrut",style:{height:"2.7em"}}),(0,l.kt)("span",{parentName:"span",className:"sizing reset-size6 size3 mtight"},(0,l.kt)("span",{parentName:"span",className:"mord mtight"},"2"))))))))))))," or ",(0,l.kt)("span",{parentName:"p",className:"math math-inline"},(0,l.kt)("span",{parentName:"span",className:"katex"},(0,l.kt)("span",{parentName:"span",className:"katex-mathml"},(0,l.kt)("math",{parentName:"span",xmlns:"http://www.w3.org/1998/Math/MathML"},(0,l.kt)("semantics",{parentName:"math"},(0,l.kt)("mrow",{parentName:"semantics"},(0,l.kt)("msup",{parentName:"mrow"},(0,l.kt)("mi",{parentName:"msup"},"x"),(0,l.kt)("mn",{parentName:"msup"},"3")),(0,l.kt)("mo",{parentName:"mrow"},"+"),(0,l.kt)("mi",{parentName:"mrow"},"x")),(0,l.kt)("annotation",{parentName:"semantics",encoding:"application/x-tex"},"x^3 + x")))),(0,l.kt)("span",{parentName:"span",className:"katex-html","aria-hidden":"true"},(0,l.kt)("span",{parentName:"span",className:"base"},(0,l.kt)("span",{parentName:"span",className:"strut",style:{height:"0.8974em",verticalAlign:"-0.0833em"}}),(0,l.kt)("span",{parentName:"span",className:"mord"},(0,l.kt)("span",{parentName:"span",className:"mord mathnormal"},"x"),(0,l.kt)("span",{parentName:"span",className:"msupsub"},(0,l.kt)("span",{parentName:"span",className:"vlist-t"},(0,l.kt)("span",{parentName:"span",className:"vlist-r"},(0,l.kt)("span",{parentName:"span",className:"vlist",style:{height:"0.8141em"}},(0,l.kt)("span",{parentName:"span",style:{top:"-3.063em",marginRight:"0.05em"}},(0,l.kt)("span",{parentName:"span",className:"pstrut",style:{height:"2.7em"}}),(0,l.kt)("span",{parentName:"span",className:"sizing reset-size6 size3 mtight"},(0,l.kt)("span",{parentName:"span",className:"mord mtight"},"3")))))))),(0,l.kt)("span",{parentName:"span",className:"mspace",style:{marginRight:"0.2222em"}}),(0,l.kt)("span",{parentName:"span",className:"mbin"},"+"),(0,l.kt)("span",{parentName:"span",className:"mspace",style:{marginRight:"0.2222em"}})),(0,l.kt)("span",{parentName:"span",className:"base"},(0,l.kt)("span",{parentName:"span",className:"strut",style:{height:"0.4306em"}}),(0,l.kt)("span",{parentName:"span",className:"mord mathnormal"},"x")))))," as lambda functions."),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-py",metastring:"live_py title=integral",live_py:!0,title:"integral"},"def approx_integral(f, x_min, x_max, rects):\n  width = (x_max - x_min) / rects\n  return sum([width*f(x_min+i*width) for i in range(rects)])\n\nprint(approx_integral(lambda x: x, 0, 1, 250))\nprint(approx_integral(lambda x: x**2, 0, 1, 250))\nprint(approx_integral(lambda x: x**3 + x, 0, 1, 250))\n")),(0,l.kt)("h2",{id:"reduce"},"Reduce"),(0,l.kt)("p",null,"We've talked now in two lectures about mapping and filtering,\nbut there is a third common idiom often spoken of in the same context: reducing."),(0,l.kt)("p",null,"Often we find ourselves wanting to take every element in a collection\nand aggregate them together in some way. This is called ",(0,l.kt)("em",{parentName:"p"},"reducing"),"."),(0,l.kt)("p",null,"Some examples include:"),(0,l.kt)("ul",null,(0,l.kt)("li",{parentName:"ul"},"summation (adding every element in a collection together)"),(0,l.kt)("li",{parentName:"ul"},"multiplying every element in a collection together"),(0,l.kt)("li",{parentName:"ul"},"counting how many elements are in a collection"),(0,l.kt)("li",{parentName:"ul"},"getting the minimal or maximal element in a collection")),(0,l.kt)("p",null,"Some more exotic example include:"),(0,l.kt)("ul",null,(0,l.kt)("li",{parentName:"ul"},"even sorting can be done by reducing"),(0,l.kt)("li",{parentName:"ul"},"even mapping and filtering can be done by reducing")),(0,l.kt)("p",null,"Now that we have lambda functions, we can do mapping, filtering, and reducing\n(comprehensions only have machinery for mapping and filtering)"),(0,l.kt)("h3",{id:"iterative-form"},"Iterative Form"),(0,l.kt)("p",null,"Let's run with adding and multiplying together everything in our list as a\npair of examples."),(0,l.kt)("p",null,"Iteratively, we might do these:"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-py",metastring:"live_py title=Sum_Itr",live_py:!0,title:"Sum_Itr"},"l = [3,1,4,1,5,9,2,6]\ntotal = 0\nfor x in l:\n   total += x\nprint(total)\n")),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-py",metastring:"live_py title=Prod_Itr",live_py:!0,title:"Prod_Itr"},"l = [3,1,4,1,5,9,2,6]\ntotal = 1\nfor x in l:\n   total *= x\nprint(total)\n")),(0,l.kt)("p",null,"The core reduction is always of the form:"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-py"},"accumulator = INITIAL_VALUE\nfor element in COLLECTION:\n   accumulator = ACC_FUNCTION(accumulator, element)\n")),(0,l.kt)("p",null,"We can see the variables are:"),(0,l.kt)("ul",null,(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("inlineCode",{parentName:"li"},"INITIAL_VALUE"),", the initial value our accumulator is set to,"),(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("inlineCode",{parentName:"li"},"COLLECTION"),", the collection we want to reduce, and"),(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("inlineCode",{parentName:"li"},"ACC_FUNCTION"),", a function that folds an element of the collection into the accumulation.")),(0,l.kt)("p",null,"Thus, a general function based on these is quite imaginable."),(0,l.kt)("h3",{id:"python-function"},"Python Function"),(0,l.kt)("p",null,"Lo and behold, the built-in module ",(0,l.kt)("inlineCode",{parentName:"p"},"functools")," has a ",(0,l.kt)("inlineCode",{parentName:"p"},"reduce()")," function."),(0,l.kt)("p",null,(0,l.kt)("inlineCode",{parentName:"p"},"reduce()")," takes in ",(0,l.kt)("inlineCode",{parentName:"p"},"ACC_FUNCTION"),", ",(0,l.kt)("inlineCode",{parentName:"p"},"COLLECTION"),", and an optional ",(0,l.kt)("inlineCode",{parentName:"p"},"INITIAL_VALUE"),",\nin that order."),(0,l.kt)("ul",null,(0,l.kt)("li",{parentName:"ul"},"If the initial value is not provided,\nthe first element of the collection is used as the initial value,\nand all subsequent elements folded in."),(0,l.kt)("li",{parentName:"ul"},"If there is only one element (",(0,l.kt)("inlineCode",{parentName:"li"},"COLLECTION")," is empty and ",(0,l.kt)("inlineCode",{parentName:"li"},"INITIAL_VALUE")," specified ",(0,l.kt)("strong",{parentName:"li"},"or")," ",(0,l.kt)("inlineCode",{parentName:"li"},"COLLECTION"),"\nhas one element and ",(0,l.kt)("inlineCode",{parentName:"li"},"INITIAL_VALUE")," is unspecified), then ",(0,l.kt)("inlineCode",{parentName:"li"},"reduce()")," returns that one element.\n(Thus I like to set ",(0,l.kt)("inlineCode",{parentName:"li"},"INITIAL_VALUE")," as a default if possible.)"),(0,l.kt)("li",{parentName:"ul"},"If there are no elements (",(0,l.kt)("inlineCode",{parentName:"li"},"COLLECTION")," is empty and ",(0,l.kt)("inlineCode",{parentName:"li"},"INITIAL_VALUE")," is unspecified),\nthen an error occurs.")),(0,l.kt)("p",null,"So our summation and product from earlier become:"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-py",metastring:"live_py title=Sum_Reduce",live_py:!0,title:"Sum_Reduce"},"from functools import reduce\n\nl = [3,1,4,1,5,9,2,6]\ntotal = reduce(lambda x, y: x + y, l, 0)\nprint(total)\n")),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-py",metastring:"live_py title=Prod_Reduce",live_py:!0,title:"Prod_Reduce"},"from functools import reduce\n\nl = [3,1,4,1,5,9,2,6]\nprod = reduce(lambda x, y: x * y, l, 1)\nprint(prod)\n")),(0,l.kt)("p",null,"Let's just get exotic with some more examples.\nFactorial is just a specific product (1 to n), right?"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-py",metastring:"live_py title=Factorial_Reduce",live_py:!0,title:"Factorial_Reduce"},'from functools import reduce\n\ndef factorial(n):\n  return reduce(lambda x, y: x * y, range(1,n+1), 1)\n\nfor i in range(10):\n  print(f"{i}! = {factorial(i)}")\n')),(0,l.kt)("p",null,"Here's an example of computing the minimum and maximum,\nthis is a case where we don't really have of a good default to start with."),(0,l.kt)("p",null,"Note that ternary operators are kosher in lambda functions."),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-py",metastring:"live_py title=Min_Max_Reduce",live_py:!0,title:"Min_Max_Reduce"},"from functools import reduce\n\nl = [3,1,4,1,5,9,2,6]\nminimum = reduce(lambda x, y: x if x < y else y, l)\nmaximum = reduce(lambda x, y: x if x > y else y, l)\nprint(minimum)\nprint(maximum)\n")),(0,l.kt)("p",null,"Counting is an example of a reduction problem where the actual elements\nof the collection don't matter.\nThe underscore (",(0,l.kt)("inlineCode",{parentName:"p"},"_"),') is basically a "I\'m not even naming this variable" character.'),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-py",metastring:"live_py title=Count_Reduce",live_py:!0,title:"Count_Reduce"},"from functools import reduce\n\nl = [3,1,4,1,5,9,2,6]\ncount = reduce(lambda n, _: n + 1, l, 0)\nprint(count)\n")),(0,l.kt)("p",null,"Finally, as promised, mapping and filtering.\nThe thing being aggregated is a now a list, with the initial value being the empty list."),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-py",metastring:"live_py title=Map_Reduce",live_py:!0,title:"Map_Reduce"},"from functools import reduce\n\ndef my_map(f, lst):\n  return reduce(lambda l, e: l + [f(e)], lst, [])\n\nl = [3,1,4,1,5,9,2,6]\nsquares_map = map(lambda x: x ** 2, l)\nsquares_red = my_map(lambda x: x ** 2, l)\nprint(list(squares_map))\nprint(squares_red)\n")),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-py",metastring:"live_py title=Filter_Reduce",live_py:!0,title:"Filter_Reduce"},"from functools import reduce\n\ndef my_filter(cond, lst):\n  return reduce(lambda l, e: l + ([e] if cond(e) else []), lst, [])\n\nl = [3,1,4,1,5,9,2,6]\nevens_filt = filter(lambda x: x % 2 == 0, l)\nevens_red = my_filter(lambda x: x % 2 == 0, l)\nprint(list(evens_filt))\nprint(evens_red)\n")))}d.isMDXComponent=!0},85162:(e,t,n)=>{n.d(t,{Z:()=>i});var a=n(67294),l=n(86010);const r="tabItem_Ymn6";function i(e){let{children:t,hidden:n,className:i}=e;return a.createElement("div",{role:"tabpanel",className:(0,l.default)(r,i),hidden:n},t)}},74866:(e,t,n)=>{n.d(t,{Z:()=>v});var a=n(87462),l=n(67294),r=n(86010),i=n(12466),o=n(16550),s=n(91980),p=n(67392),m=n(50012);function u(e){return function(e){return l.Children.map(e,(e=>{if((0,l.isValidElement)(e)&&"value"in e.props)return e;throw new Error(`Docusaurus error: Bad <Tabs> child <${"string"==typeof e.type?e.type:e.type.name}>: all children of the <Tabs> component should be <TabItem>, and every <TabItem> should have a unique "value" prop.`)}))}(e).map((e=>{let{props:{value:t,label:n,attributes:a,default:l}}=e;return{value:t,label:n,attributes:a,default:l}}))}function c(e){const{values:t,children:n}=e;return(0,l.useMemo)((()=>{const e=t??u(n);return function(e){const t=(0,p.l)(e,((e,t)=>e.value===t.value));if(t.length>0)throw new Error(`Docusaurus error: Duplicate values "${t.map((e=>e.value)).join(", ")}" found in <Tabs>. Every value needs to be unique.`)}(e),e}),[t,n])}function d(e){let{value:t,tabValues:n}=e;return n.some((e=>e.value===t))}function h(e){let{queryString:t=!1,groupId:n}=e;const a=(0,o.k6)(),r=function(e){let{queryString:t=!1,groupId:n}=e;if("string"==typeof t)return t;if(!1===t)return null;if(!0===t&&!n)throw new Error('Docusaurus error: The <Tabs> component groupId prop is required if queryString=true, because this value is used as the search param name. You can also provide an explicit value such as queryString="my-search-param".');return n??null}({queryString:t,groupId:n});return[(0,s._X)(r),(0,l.useCallback)((e=>{if(!r)return;const t=new URLSearchParams(a.location.search);t.set(r,e),a.replace({...a.location,search:t.toString()})}),[r,a])]}function f(e){const{defaultValue:t,queryString:n=!1,groupId:a}=e,r=c(e),[i,o]=(0,l.useState)((()=>function(e){let{defaultValue:t,tabValues:n}=e;if(0===n.length)throw new Error("Docusaurus error: the <Tabs> component requires at least one <TabItem> children component");if(t){if(!d({value:t,tabValues:n}))throw new Error(`Docusaurus error: The <Tabs> has a defaultValue "${t}" but none of its children has the corresponding value. Available values are: ${n.map((e=>e.value)).join(", ")}. If you intend to show no default tab, use defaultValue={null} instead.`);return t}const a=n.find((e=>e.default))??n[0];if(!a)throw new Error("Unexpected error: 0 tabValues");return a.value}({defaultValue:t,tabValues:r}))),[s,p]=h({queryString:n,groupId:a}),[u,f]=function(e){let{groupId:t}=e;const n=function(e){return e?`docusaurus.tab.${e}`:null}(t),[a,r]=(0,m.Nk)(n);return[a,(0,l.useCallback)((e=>{n&&r.set(e)}),[n,r])]}({groupId:a}),k=(()=>{const e=s??u;return d({value:e,tabValues:r})?e:null})();(0,l.useLayoutEffect)((()=>{k&&o(k)}),[k]);return{selectedValue:i,selectValue:(0,l.useCallback)((e=>{if(!d({value:e,tabValues:r}))throw new Error(`Can't select invalid tab value=${e}`);o(e),p(e),f(e)}),[p,f,r]),tabValues:r}}var k=n(72389);const g="tabList__CuJ",N="tabItem_LNqP";function y(e){let{className:t,block:n,selectedValue:o,selectValue:s,tabValues:p}=e;const m=[],{blockElementScrollPositionUntilNextRender:u}=(0,i.o5)(),c=e=>{const t=e.currentTarget,n=m.indexOf(t),a=p[n].value;a!==o&&(u(t),s(a))},d=e=>{let t=null;switch(e.key){case"Enter":c(e);break;case"ArrowRight":{const n=m.indexOf(e.currentTarget)+1;t=m[n]??m[0];break}case"ArrowLeft":{const n=m.indexOf(e.currentTarget)-1;t=m[n]??m[m.length-1];break}}t?.focus()};return l.createElement("ul",{role:"tablist","aria-orientation":"horizontal",className:(0,r.default)("tabs",{"tabs--block":n},t)},p.map((e=>{let{value:t,label:n,attributes:i}=e;return l.createElement("li",(0,a.Z)({role:"tab",tabIndex:o===t?0:-1,"aria-selected":o===t,key:t,ref:e=>m.push(e),onKeyDown:d,onClick:c},i,{className:(0,r.default)("tabs__item",N,i?.className,{"tabs__item--active":o===t})}),n??t)})))}function b(e){let{lazy:t,children:n,selectedValue:a}=e;if(n=Array.isArray(n)?n:[n],t){const e=n.find((e=>e.props.value===a));return e?(0,l.cloneElement)(e,{className:"margin-top--md"}):null}return l.createElement("div",{className:"margin-top--md"},n.map(((e,t)=>(0,l.cloneElement)(e,{key:t,hidden:e.props.value!==a}))))}function _(e){const t=f(e);return l.createElement("div",{className:(0,r.default)("tabs-container",g)},l.createElement(y,(0,a.Z)({},e,t)),l.createElement(b,(0,a.Z)({},e,t)))}function v(e){const t=(0,k.Z)();return l.createElement(_,(0,a.Z)({key:String(t)},e))}}}]);