"use strict";(self.webpackChunk=self.webpackChunk||[]).push([[7832],{3905:(e,t,n)=>{n.d(t,{Zo:()=>u,kt:()=>k});var a=n(67294);function r(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function i(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);t&&(a=a.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,a)}return n}function l(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?i(Object(n),!0).forEach((function(t){r(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):i(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function o(e,t){if(null==e)return{};var n,a,r=function(e,t){if(null==e)return{};var n,a,r={},i=Object.keys(e);for(a=0;a<i.length;a++)n=i[a],t.indexOf(n)>=0||(r[n]=e[n]);return r}(e,t);if(Object.getOwnPropertySymbols){var i=Object.getOwnPropertySymbols(e);for(a=0;a<i.length;a++)n=i[a],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(r[n]=e[n])}return r}var s=a.createContext({}),p=function(e){var t=a.useContext(s),n=t;return e&&(n="function"==typeof e?e(t):l(l({},t),e)),n},u=function(e){var t=p(e.components);return a.createElement(s.Provider,{value:t},e.children)},m="mdxType",d={inlineCode:"code",wrapper:function(e){var t=e.children;return a.createElement(a.Fragment,{},t)}},c=a.forwardRef((function(e,t){var n=e.components,r=e.mdxType,i=e.originalType,s=e.parentName,u=o(e,["components","mdxType","originalType","parentName"]),m=p(n),c=r,k=m["".concat(s,".").concat(c)]||m[c]||d[c]||i;return n?a.createElement(k,l(l({ref:t},u),{},{components:n})):a.createElement(k,l({ref:t},u))}));function k(e,t){var n=arguments,r=t&&t.mdxType;if("string"==typeof e||r){var i=n.length,l=new Array(i);l[0]=c;var o={};for(var s in t)hasOwnProperty.call(t,s)&&(o[s]=t[s]);o.originalType=e,o[m]="string"==typeof e?e:r,l[1]=o;for(var p=2;p<i;p++)l[p]=n[p];return a.createElement.apply(null,l)}return a.createElement.apply(null,n)}c.displayName="MDXCreateElement"},13688:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>s,contentTitle:()=>l,default:()=>m,frontMatter:()=>i,metadata:()=>o,toc:()=>p});var a=n(87462),r=(n(67294),n(3905));const i={title:"Section 04 (Jared Yeager)"},l="Booleans and Assert",o={unversionedId:"booleans-and-assert/Jared/index",id:"booleans-and-assert/Jared/index",title:"Section 04 (Jared Yeager)",description:"This is not entirely complete, you may notice some TODOs I have left for myself.",source:"@site/main/lectures/05-booleans-and-assert/Jared/index.md",sourceDirName:"05-booleans-and-assert/Jared",slug:"/booleans-and-assert/Jared/",permalink:"/main/lectures/booleans-and-assert/Jared/",draft:!1,tags:[],version:"current",frontMatter:{title:"Section 04 (Jared Yeager)"},sidebar:"tutorialSidebar",previous:{title:"Lec 05 Booleans & Assert",permalink:"/main/lectures/booleans-and-assert/"},next:{title:"Lec 06 Lists, Tuples, Sets",permalink:"/main/lectures/lists-tuples-strings/"}},s={},p=[{value:"Assignment Updates",id:"assignment-updates",level:2},{value:"Booleans",id:"booleans",level:2},{value:"Comparisons",id:"comparisons",level:3},{value:"Float Representation Error",id:"float-representation-error",level:3},{value:"Logical Operators",id:"logical-operators",level:2},{value:"Precedence",id:"precedence",level:3},{value:"Misc",id:"misc",level:3},{value:"Assert",id:"assert",level:2},{value:"Conversions and Truthy/Falsy Values",id:"conversions-and-truthyfalsy-values",level:2},{value:"Misc: More Built-In Functions",id:"misc-more-built-in-functions",level:2}],u={toc:p};function m(e){let{components:t,...n}=e;return(0,r.kt)("wrapper",(0,a.Z)({},u,n,{components:t,mdxType:"MDXLayout"}),(0,r.kt)("h1",{id:"booleans-and-assert"},"Booleans and Assert"),(0,r.kt)("admonition",{type:"caution"},(0,r.kt)("p",{parentName:"admonition"},"This is not entirely complete, you may notice some TODOs I have left for myself.")),(0,r.kt)("h2",{id:"assignment-updates"},"Assignment Updates"),(0,r.kt)("p",null,"Stuff due this week:"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},"HW 1: ",(0,r.kt)("strong",{parentName:"li"},"Due Wednesday 2/22")),(0,r.kt)("li",{parentName:"ul"},"Quiz 3: ",(0,r.kt)("strong",{parentName:"li"},"Due Thursday 2/23")),(0,r.kt)("li",{parentName:"ul"},"Lab 3: ",(0,r.kt)("strong",{parentName:"li"},"Due Friday 2/24")),(0,r.kt)("li",{parentName:"ul"},"[TODO: Reading? Presumably Thursday.]")),(0,r.kt)("p",null,"Stuff due next week:"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},"HW 2: ",(0,r.kt)("strong",{parentName:"li"},"Due Wednesday 3/1")),(0,r.kt)("li",{parentName:"ul"},"Quiz 4: ",(0,r.kt)("strong",{parentName:"li"},"Due Thursday 3/2")),(0,r.kt)("li",{parentName:"ul"},"Lab 4: ",(0,r.kt)("strong",{parentName:"li"},"Due Friday 3/3")),(0,r.kt)("li",{parentName:"ul"},"[TODO: Reading? Presumably Thursday.]")),(0,r.kt)("h2",{id:"booleans"},"Booleans"),(0,r.kt)("p",null,"So far we've learned about types for numbers (whole and decimal),\ntext, and even nothingness itself."),(0,r.kt)("p",null,"Now comes our final fundamental type: ",(0,r.kt)("em",{parentName:"p"},"booleans")," (",(0,r.kt)("inlineCode",{parentName:"p"},"bool"),"s), the type for truth."),(0,r.kt)("p",null,"There are only two possible values for ",(0,r.kt)("inlineCode",{parentName:"p"},"bool"),"s: ",(0,r.kt)("inlineCode",{parentName:"p"},"True")," and ",(0,r.kt)("inlineCode",{parentName:"p"},"False"),"."),(0,r.kt)("h3",{id:"comparisons"},"Comparisons"),(0,r.kt)("p",null,"So what can give us these booleans values?\nFirst and foremost, comparison between numbers. Some operators:\n",(0,r.kt)("inlineCode",{parentName:"p"},"x == y"),": returns ",(0,r.kt)("inlineCode",{parentName:"p"},"True")," if ",(0,r.kt)("inlineCode",{parentName:"p"},"x")," equals ",(0,r.kt)("inlineCode",{parentName:"p"},"y"),", otherwise ",(0,r.kt)("inlineCode",{parentName:"p"},"False"),".\n",(0,r.kt)("inlineCode",{parentName:"p"},"x != y"),": returns ",(0,r.kt)("inlineCode",{parentName:"p"},"True")," if ",(0,r.kt)("inlineCode",{parentName:"p"},"x")," does not equal ",(0,r.kt)("inlineCode",{parentName:"p"},"y"),", otherwise ",(0,r.kt)("inlineCode",{parentName:"p"},"False"),".\n",(0,r.kt)("inlineCode",{parentName:"p"},"x < y"),": returns ",(0,r.kt)("inlineCode",{parentName:"p"},"True")," if ",(0,r.kt)("inlineCode",{parentName:"p"},"x")," is strictly less than ",(0,r.kt)("inlineCode",{parentName:"p"},"y"),", otherwise ",(0,r.kt)("inlineCode",{parentName:"p"},"False"),".\n",(0,r.kt)("inlineCode",{parentName:"p"},"x > y"),": returns ",(0,r.kt)("inlineCode",{parentName:"p"},"True")," if ",(0,r.kt)("inlineCode",{parentName:"p"},"x")," is strictly greater than ",(0,r.kt)("inlineCode",{parentName:"p"},"y"),", otherwise ",(0,r.kt)("inlineCode",{parentName:"p"},"False"),".\n",(0,r.kt)("inlineCode",{parentName:"p"},"x <= y"),": returns ",(0,r.kt)("inlineCode",{parentName:"p"},"True")," if ",(0,r.kt)("inlineCode",{parentName:"p"},"x")," is less than or equal to ",(0,r.kt)("inlineCode",{parentName:"p"},"y"),", otherwise ",(0,r.kt)("inlineCode",{parentName:"p"},"False"),".\n",(0,r.kt)("inlineCode",{parentName:"p"},"x >= y"),": returns ",(0,r.kt)("inlineCode",{parentName:"p"},"True")," if ",(0,r.kt)("inlineCode",{parentName:"p"},"x")," is greater than or equal to ",(0,r.kt)("inlineCode",{parentName:"p"},"y"),", otherwise ",(0,r.kt)("inlineCode",{parentName:"p"},"False"),"."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-py",metastring:"live_py title=Number_Comparisons",live_py:!0,title:"Number_Comparisons"},"print(3 == 5)  # False\nprint(3 != 5)  # True\nprint(3.5 > 5) # False\nprint(5 <= 5)  # True\n")),(0,r.kt)("p",null,'Funnily enough, you can use all these operators on strings too.\nThe less than vs greater than become lexicographical ordering,\nwith earlier strings being "less"\n(all capital letters are less than all lower case letters).'),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-py",metastring:"live_py title=String_Comparisons",live_py:!0,title:"String_Comparisons"},'print("Foo" == "Foo")  # True\nprint("Foo" != "foo")  # True\nprint("Foo" < "foo")   # True\nprint("Fool" <= "Foo") # False\n')),(0,r.kt)("h3",{id:"float-representation-error"},"Float Representation Error"),(0,r.kt)("p",null,"There is a dangerous pitfall lurking in checking if ",(0,r.kt)("inlineCode",{parentName:"p"},"floats")," are equal:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-py",metastring:"live_py title=Float_NE",live_py:!0,title:"Float_NE"},"print(.1 + .2 == .3) # False\n")),(0,r.kt)("p",null,"Why is ",(0,r.kt)("inlineCode",{parentName:"p"},".1 + .2")," not ",(0,r.kt)("inlineCode",{parentName:"p"},".3"),".\nForcing them to be be more thoroughly displayed we see something interesting"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-py",metastring:"live_py title=Float_Representation",live_py:!0,title:"Float_Representation"},'print(f"{.1    : .17f}") # 0.10000000000000001\nprint(f"{.2    : .17f}") # 0.20000000000000001\nprint(f"{.1+.2 : .17f}") # 0.30000000000000004\nprint(f"{.3    : .17f}") # 0.29999999999999999\n')),(0,r.kt)("p",null,"The same way that we can not represent 1/3 perfectly in decimal form,\nthere are plenty of values the computer can not represent perfectly,\nand so slight arithmetic errors can appear."),(0,r.kt)("p",null,"If we want to see if two floats are equal,\nyou can check the absolute value of the difference against a tolerance or use ",(0,r.kt)("inlineCode",{parentName:"p"},"math.isclose()")),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-py",metastring:"live_py title=Float_Tolerance",live_py:!0,title:"Float_Tolerance"},"import math\nprint(.1 + .2 == .3)             # False\nprint(abs(.1 + .2 - .3) < .001)  # True\nprint(math.isclose(.1 + .2, .3)) # True\n")),(0,r.kt)("admonition",{type:"caution"},(0,r.kt)("p",{parentName:"admonition"},"Below code is throwing an error on the website,\nbut not is run in isolation in a file.\nStill working on that.")),(0,r.kt)("p",null,"Yet even within these, beware.\n",(0,r.kt)("inlineCode",{parentName:"p"},"math.isclose()")," defaults to using a tolerance based on the two arguments,\nso there will be an issue if one of the two values is ",(0,r.kt)("inlineCode",{parentName:"p"},"0.0"),".\nThere is a way to specify an absolute tolerance to get around this:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-py",metastring:"live_py title=IsClose_Tolerance",live_py:!0,title:"IsClose_Tolerance"},"import math\nprint(math.isclose(.1 + .2 - .3, 0))                # False\nprint(math.isclose(.1 + .2 - .3, 0, abs_tol=0.001)) # True\n")),(0,r.kt)("h2",{id:"logical-operators"},"Logical Operators"),(0,r.kt)("p",null,"There are new operators that work on booleans:"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"x and y"),": returns ",(0,r.kt)("inlineCode",{parentName:"li"},"True")," if ",(0,r.kt)("inlineCode",{parentName:"li"},"x")," and ",(0,r.kt)("inlineCode",{parentName:"li"},"y")," are both ",(0,r.kt)("inlineCode",{parentName:"li"},"True"),", otherwise returns ",(0,r.kt)("inlineCode",{parentName:"li"},"False"),"."),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"x or y"),": returns ",(0,r.kt)("inlineCode",{parentName:"li"},"True")," if either ",(0,r.kt)("inlineCode",{parentName:"li"},"x")," or ",(0,r.kt)("inlineCode",{parentName:"li"},"y")," is ",(0,r.kt)("inlineCode",{parentName:"li"},"True"),", otherwise returns ",(0,r.kt)("inlineCode",{parentName:"li"},"False"),"."),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"not x"),": returns ",(0,r.kt)("inlineCode",{parentName:"li"},"True")," if ",(0,r.kt)("inlineCode",{parentName:"li"},"x")," is ",(0,r.kt)("inlineCode",{parentName:"li"},"False")," and returns ",(0,r.kt)("inlineCode",{parentName:"li"},"False")," if ",(0,r.kt)("inlineCode",{parentName:"li"},"x")," is ",(0,r.kt)("inlineCode",{parentName:"li"},"True"),".")),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-py",metastring:"live_py title=Logic",live_py:!0,title:"Logic"},"print(5 < 6 and 6 < 7)  # True\nprint(5 >= 6 or 6 >= 7) # False\nprint(not 1 == 5)       # True\n")),(0,r.kt)("h3",{id:"precedence"},"Precedence"),(0,r.kt)("p",null,"As there is an order of operations for math, so there is for logic."),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},"Parentheses always win"),(0,r.kt)("li",{parentName:"ul"},"Evaluation of math is done first (",(0,r.kt)("inlineCode",{parentName:"li"},"**"),",then ",(0,r.kt)("inlineCode",{parentName:"li"},"*"),",",(0,r.kt)("inlineCode",{parentName:"li"},"/"),",",(0,r.kt)("inlineCode",{parentName:"li"},"//"),",",(0,r.kt)("inlineCode",{parentName:"li"},"%"),", then ",(0,r.kt)("inlineCode",{parentName:"li"},"+"),",",(0,r.kt)("inlineCode",{parentName:"li"},"-"),")"),(0,r.kt)("li",{parentName:"ul"},"Then comparisons ",(0,r.kt)("inlineCode",{parentName:"li"},"=="),", ",(0,r.kt)("inlineCode",{parentName:"li"},"!="),", ",(0,r.kt)("inlineCode",{parentName:"li"},"<="),", ",(0,r.kt)("inlineCode",{parentName:"li"},">="),", ",(0,r.kt)("inlineCode",{parentName:"li"},"<"),", ",(0,r.kt)("inlineCode",{parentName:"li"},">")),(0,r.kt)("li",{parentName:"ul"},"Then ",(0,r.kt)("inlineCode",{parentName:"li"},"not")),(0,r.kt)("li",{parentName:"ul"},"Then ",(0,r.kt)("inlineCode",{parentName:"li"},"and")),(0,r.kt)("li",{parentName:"ul"},"Then ",(0,r.kt)("inlineCode",{parentName:"li"},"or"))),(0,r.kt)("p",null,"So for instance:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-py",metastring:"live_py title=Precedence",live_py:!0,title:"Precedence"},"# 3 ** 3 == 1 and 6 - 7 < 0 or not 1 % 2 == 0\n#     27 == 1 and    -1 < 0 or not     1 == 0\n#     False   and    True   or not     False\n#     False   and    True   or True\n#     False                 or True\n#     True\nprint(3 ** 3 == 1 and 6 - 7 < 0 or not 1 % 2 == 0)\n")),(0,r.kt)("p",null,"That said, using parentheses for some visual clarity is advised."),(0,r.kt)("h3",{id:"misc"},"Misc"),(0,r.kt)("details",null,(0,r.kt)("summary",null,(0,r.kt)("b",null,"Extra: DeMorgan's Laws")),(0,r.kt)("p",null,"A fancy name for a set of logical rules.\nDeMorgen's Laws tell us that:"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"not (x and y)")," is equivalent to ",(0,r.kt)("inlineCode",{parentName:"li"},"not x or not y")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"not (x or y)")," is equivalent to ",(0,r.kt)("inlineCode",{parentName:"li"},"not x and not y"))),(0,r.kt)("p",null,"You can fairly easily convince yourself this is true via some truth tables."),(0,r.kt)("p",null,"[TODO: Truth Tables]")),(0,r.kt)("details",null,(0,r.kt)("summary",null,(0,r.kt)("b",null,"Extra: Distributive Laws")),(0,r.kt)("p",null,"[TODO]")),(0,r.kt)("details",null,(0,r.kt)("summary",null,(0,r.kt)("b",null,"Extra: Short Circuiting")),(0,r.kt)("p",null,"[TODO]")),(0,r.kt)("h2",{id:"assert"},"Assert"),(0,r.kt)("p",null,(0,r.kt)("inlineCode",{parentName:"p"},"assert")," is a special command that takes a boolean (or something that evaluatse to a boolean)\nand an error message in string form; it checks the condition, and throws an error if\nthe condition is not met."),(0,r.kt)("p",null,"This can be used as a sort of gate/checkpoint to prevent illegal states (such as illegal input),\nthe idea being that an explicit error is easier to notice and address than\nsomething wrong/unexpected but not illegal going on in a more invisible manner."),(0,r.kt)("p",null,"Below is an example of exponentiation where we may want the result to always be an int."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-py",metastring:"live_py title=Interger_Exp",live_py:!0,title:"Interger_Exp"},'def int_exp(x:int, y:int):\n  # We can use == for type comparison, don\'t want floats if we want an int result\n  assert type(x) == int, "Illegal type for x"\n  assert type(y) == int, "Illegal type for y"\n  return x ** y\n\nz = int_exp(3, -1)\n# something triggering this assert would tell us improvements can be made\nassert type(z) == int, "int_exp() produced illegal return"\nprint(z)\n')),(0,r.kt)("p",null,"That last error message could clue us in to a missed case.\nThat can then be fixed:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-py",metastring:"live_py title=Interger_Exp_Fixed",live_py:!0,title:"Interger_Exp_Fixed"},'def int_exp(x:int, y:int):\n  # We can use == for type comparison\n  assert type(x) == int, "Illegal type for x"\n  assert type(y) == int, "Illegal type for y"\n  assert y >= 0, f"Illegal value for y (y is {y})"\n  return x ** y\n\n# z = int_exp(3.0, 5) # AssertionError: Illegal type for x\n# z = int_exp(3, .5)  # AssertionError: Illegal type for y\n# z = int_exp(3, -1)  # AssertionError: Illegal value for y (y is -1)\n\nz = int_exp(3, 5)\n# If int_exp was mis-implemented, we might trigger the asert below.\nassert type(z) == int, "int_exp() produced illegal return"\nprint(z)\n')),(0,r.kt)("h2",{id:"conversions-and-truthyfalsy-values"},"Conversions and Truthy/Falsy Values"),(0,r.kt)("p",null,"Lets talk about how booleans interact with type conversion.\nConverting ",(0,r.kt)("strong",{parentName:"p"},"from")," booleans we can demonstrate exhaustively:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-py",metastring:"live_py title=From_Bool",live_py:!0,title:"From_Bool"},'print(int(True))    # 1\nprint(int(False))   # 0\nprint(float(True))  # 1.0\nprint(float(False)) # 0.0\nprint(str(True))    # "True" \nprint(str(False))   # "False" \n')),(0,r.kt)("p",null,'Converting to booleans is more interesting story.\nEvery value is either "Truthy" (converts to true) or "Falsy" (coverts to false).\nThe general rule is, for a given type, the "empty"-or-"zero"-like values are falsy,\nand everything else is truthy.'),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-py",metastring:"live_py title=To_Bool",live_py:!0,title:"To_Bool"},'import math\nprint(bool(0))         # False\nprint(bool(0.0))       # False\nprint(bool(-0.0))      # False\nprint(bool(math.nan))  # False, interestingly enough\nprint(bool(""))        # False\nprint(bool(None))      # False\n\nprint(bool(1))         # True\nprint(bool(-57))       # True\nprint(bool(1.0))       # True\nprint(bool(-math.inf)) # True\nprint(bool("foo"))     # True\nprint(bool("False"))   # True, which might surprise you\n')),(0,r.kt)("h2",{id:"misc-more-built-in-functions"},"Misc: More Built-In Functions"),(0,r.kt)("p",null,"Python is a fairly well developed language. So for a lot of really basic properties\nof numbers and strings, there is some sort of built-in or library function to\ncompute/check said property."),(0,r.kt)("p",null,'It is impossible to memorise all the functions that exist, but there is also no need to.\nIn practice, if you wanted to know something like the length of the string you\nwould search the internet for "python string length function".\nAnd you would presumably find the ',(0,r.kt)("inlineCode",{parentName:"p"},"len()")," function and some examples online."),(0,r.kt)("p",null,'Some example "signatures" of such functions:'),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"len(s)"),": gets the length of a string."),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"min(n1, n2, n3, ...)"),": gets the minimum number in a list."),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"max(n1, n2, n3, ...)"),": gets the maximum number in a list."),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"round(number, ndigits=None)"),": rounds a number to ",(0,r.kt)("inlineCode",{parentName:"li"},"ndigits")," digits,\nthe default is to round to the nearest whole number."),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"abs(x)"),": gets the absolute value of a number.")))}m.isMDXComponent=!0}}]);